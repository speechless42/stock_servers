"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Streamer = void 0;
const events_1 = require("events");
const ws_1 = require("ws");
const trade_core_1 = require("@fugle/trade-core");
const enums_1 = require("./enums");
const constants_1 = require("./constants");
const SOCKET = Symbol('Streamer#socket');
class Streamer extends events_1.EventEmitter {
    constructor(url) {
        super();
        this.url = url;
    }
    get socket() {
        return this[SOCKET];
    }
    set socket(socket) {
        this[SOCKET] = socket;
    }
    connect() {
        this.socket = new ws_1.WebSocket(this.url);
        this.socket.onopen = () => this.emit(constants_1.CONNECT_EVENT);
        this.socket.onmessage = event => this.emit(constants_1.MESSAGE_EVENT, event.data);
        this.socket.onerror = event => this.emit(constants_1.ERROR_EVENT, event.error);
        this.socket.onclose = () => this.emit(constants_1.DISCONNECT_EVENT);
        this.on(constants_1.MESSAGE_EVENT, message => this.handleMessage(message));
        return this;
    }
    disconnect() {
        this.socket.close();
        return this;
    }
    handleMessage(message) {
        try {
            const msg = JSON.parse((0, trade_core_1.convertWsObject)(message));
            const kind = msg.kind;
            const handleMessage = {
                [enums_1.MessageKind.ACK]: () => this.emit(constants_1.ORDER_EVENT, msg),
                [enums_1.MessageKind.MAT]: () => this.emit(constants_1.TRADE_EVENT, msg),
            };
            handleMessage[kind] && handleMessage[kind]();
        }
        catch (err) {
            return;
        }
    }
}
exports.Streamer = Streamer;
