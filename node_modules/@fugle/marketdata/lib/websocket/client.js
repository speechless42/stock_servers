"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebSocketClient = void 0;
const events = require("events");
const WebSocket = require("isomorphic-ws");
const constants_1 = require("../constants");
class WebSocketClient extends events.EventEmitter {
    constructor(options) {
        super();
        this.options = options;
    }
    connect() {
        this.socket = new WebSocket(this.options.url);
        this.socket.onopen = () => this.emit(constants_1.CONNECT_EVENT);
        this.socket.onmessage = event => this.emit(constants_1.MESSAGE_EVENT, event.data);
        this.socket.onerror = event => this.emit(constants_1.ERROR_EVENT, event.error);
        this.socket.onclose = event => this.emit(constants_1.DISCONNECT_EVENT, event);
        this.on(constants_1.CONNECT_EVENT, () => this.authenticate());
        this.on(constants_1.MESSAGE_EVENT, message => this.handleMessage(message));
        return new Promise((resolve, reject) => {
            this.on(constants_1.AUTHENTICATED_EVENT, (data) => resolve(data));
            this.on(constants_1.UNAUTHENTICATED_EVENT, (data) => reject(data));
        });
    }
    disconnect() {
        this.socket.close();
    }
    subscribe(params) {
        this.send({ event: 'subscribe', data: params });
    }
    unsubscribe(params) {
        this.send({ event: 'unsubscribe', data: params });
    }
    ping(params) {
        this.send({ event: 'ping', data: params });
    }
    authenticate() {
        if (this.options.apiKey) {
            this.send({ event: 'auth', data: { apikey: this.options.apiKey } });
        }
        if (this.options.bearerToken) {
            this.send({ event: 'auth', data: { token: this.options.bearerToken } });
        }
    }
    send(message) {
        this.socket.send(JSON.stringify(message));
    }
    handleMessage(message) {
        try {
            const { event, data } = JSON.parse(message);
            if (event === constants_1.AUTHENTICATED_EVENT) {
                this.emit(constants_1.AUTHENTICATED_EVENT, data);
            }
            if (event === constants_1.ERROR_EVENT) {
                if (data && data.message === constants_1.UNAUTHENTICATED_MESSAGE) {
                    this.emit(constants_1.UNAUTHENTICATED_EVENT, data);
                }
            }
        }
        catch (err) { }
    }
}
exports.WebSocketClient = WebSocketClient;
